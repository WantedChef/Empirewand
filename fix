op! Hier is een compact maar compleet plan om **alle SpotBugs-fouten** op te ruimen, met concrete patronen en quick-fixes per categorie. Je hoeft niet alles in één keer te doen: werk per sectie en commit klein.

# 1) EI / EI2 — “Exposes Internal Representation”

**Probleem:** je slaat externe, muteerbare objecten op of geeft interne velden direct terug.

**Waar:** o.a. `DeathSyncPolymorphListener`, `PaperScheduler`, `TaskManager`, listeners (`WandCastListener` etc.), services (`OptimizedParticleEngine`, `WandServiceImpl`), events (`SpellCastEvent#getCaster()`), `WandTemplateImpl#getDisplayName()`, `PrereqInterface.CheckResult`.

**Doelpatroon:**

* Maak velden **`private final`** en **geef ze niet door via getters** (of geef alleen een **leesinterface**).
* Indien je toch een mutabel object móét retourneren: **defensive copy** of **unmodifiable wrapper**.
* Sla **alleen de kleinste benodigde interface** op (niet de hele `JavaPlugin` als je alleen `Logger` of `Scheduler` gebruikt).

**Snippets:**

```java
public final class WandSwapHandListener implements Listener {
  private final Plugin plugin;
  public WandSwapHandListener(Plugin plugin) {
    this.plugin = Objects.requireNonNull(plugin, "plugin");
  }
  // GEEN getter die plugin teruggeeft.
}
```

```java
// Event: geef geen mutabel object terug
public final class SpellCastEvent extends Event {
  private final UUID casterId; // ipv Player
  public Player getCaster(Server server) { return server.getPlayer(casterId); } // resolved on-demand
}
```

```java
// Unmodifiable / copy
public Component getDisplayName() {
  return displayName == null ? Component.empty() : displayName; // Adventure Components zijn immutabel,
  // maar als SpotBugs blijft zeuren: overweeg een @SuppressFBWarnings met duidelijke justification.
}
```

```java
// Collections
return Collections.unmodifiableMap(configByKey);
```

> Tip: Voor Adventure `Component` is dit feitelijk een false positive. Voeg dan **spotbugs-annotations** toe en plaats **gerichte** suppressions met motivatie:

```gradle
dependencies { compileOnly "com.github.spotbugs:spotbugs-annotations:4.8.6" }
```

```java
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(
  value = {"EI", "EI_EXPOSE_REP"},
  justification = "Adventure Component is immutable by design"
)
```

# 2) CT — “Constructor Throws, Partially Initialized”

**Probleem:** constructors doen werk dat kan falen → object half geïnitialiseerd (ook “finalizer attack” warning).

**Waar:** `PerformanceMonitor`, `Keys.PersistentDataTypeWrapper`, `OptimizedParticleEngine`, `FxService`, `ConfigService`/`MigrationService`, `MetricsService`, `ProjectileSpell`(Builder), `Spell`, diverse *Adapter*s.

**Fix-strategie:**

* Houd constructors **licht en bij voorkeur `private`**; verplaats falende initialisatie naar **`init()`** of een **static factory**.
* Maak alle velden **`final`**, initialiseer met veilige defaults, en laat de factory het “zware” werk doen.
* Heb je (nog) een `finalize()` ergens? **Verwijderen**; gebruik `Cleaner` als je opruimwerk nodig hebt.

**Snippets:**

```java
public final class PerformanceMonitor {
  private final Logger logger;
  private PerformanceMonitor(Logger logger) { this.logger = Objects.requireNonNull(logger); }
  public static PerformanceMonitor create(Logger logger) throws IOException {
    PerformanceMonitor pm = new PerformanceMonitor(logger);
    pm.init(); // alles wat kan gooien
    return pm;
  }
  private void init() throws IOException { /* ... */ }
}
```

# 3) SING / LI — Singleton correct maken

**Probleem:** `EmpireWandAPI.get()` heeft incorrecte lazy init en is niet synchroon.

**Fix (Holder-idiom):**

```java
public final class EmpireWandAPI {
  private EmpireWandAPI() {}
  private static class Holder {
    static final EmpireWandAPI INSTANCE = new EmpireWandAPI();
  }
  public static EmpireWandAPI get() { return Holder.INSTANCE; }
}
```

*Alternatief:* `enum` singleton of `volatile` + DCL.

# 4) NP — Possible Null Pointer

**Waar:** `Spell.cast`, `ProjectileSpell.onProjectileHit`, `Kajarrow.handleHit`.

**Fix-patroon:**

* **Guard clauses** + `Objects.requireNonNull` bij inputs.
* Gebruik `Optional` waar passend.
* Check Bukkit API die `@Nullable` kan teruggeven (targets, world, shooter, hitBlock).

**Snippet:**

```java
Projectile proj = event.getEntity();
Entity hit = event.getHitEntity();
if (proj == null || hit == null) return; // guard
```

# 5) RCN — Redundant null check

**Waar:** `BloodBarrier`, `BindTypeCommand`, `EmpireAura`.

**Fix:** verwijder overbodige checks (houd code schoon en stil).

# 6) MS — Static getter expose rep

**Waar:** `Afterimages.get()` geeft `manager` terug.

**Fix:**

* Geef **interface** of **read-only façade** terug, of maak methoden op de klasse zelf i.p.v. de manager te exposen.

```java
public final class Afterimages {
  private static final AfterimageManager manager = new AfterimageManager();
  public static void spawnTrail(Player p) { manager.spawnTrail(p); }
  // geen get() meer of retourneer een publiek interface
}
```

# 7) ICAST — Long overflow door late cast

**Waar:** `Mephiaura.AuraData.tick()`, `ShadowCloak.tryShadowStep()`.

**Fix:**

```java
long delay = (long) intervalMs * repeats; // cast operand vóór de vermenigvuldiging
```

# 8) FL — Floating point loop counters

**Fix:** gebruik `int` teller en bereken double afgeleid.

```java
for (int i = 0; i < steps; i++) {
  double t = i / (double) steps;
}
```

# 9) WMI — Inefficiënte keySet-iteratie

**Waar:** `SpellManagerImpl.reload()`.

**Fix:**

```java
for (Map.Entry<String, Spell> e : spells.entrySet()) {
  // gebruik zowel key als value
}
```

# 10) IS — Inconsistent synchronization

**Waar:** `AsyncSpellProcessor.MetricsCollector.totalProcessingTime`.

**Fix-opties (kies 1):**

* Vervang veld door **`LongAdder`**:

```java
private final LongAdder totalProcessingTime = new LongAdder();
public void addTime(long ns){ totalProcessingTime.add(ns); }
public long sum(){ return totalProcessingTime.sum(); }
```

* Of **alles** via hetzelfde lock of `AtomicLong`.

# 11) RV — Return value ignored

**Waar:** `WandServiceImpl` negeert `WandTemplate.Builder.build()`.

**Fix:** gebruik de return value of verwijder de aanroep als die nutteloos is.

```java
WandTemplate tpl = builder.build();
registry.register(tpl);
```

# 12) Events & Builders: defensieve modellen

* **Events**: sla **IDs / snapshots** op (UUID, Location clone) i.p.v. live Bukkit objecten.
* **Builders**: sla alleen **immutable** data op; pas conversie naar Bukkit types toe bij `build()`.

**Location/Vector defensief:**

```java
this.origin = origin.clone();
public Location getOrigin(){ return origin.clone(); }
```

# 13) Listeners/Services die `Plugin` opslaan (veel EI2 hits)

* Sla **alleen** de services op die je nodig hebt (`Logger`, `Scheduler`, `ConfigService`), of injecteer een **kleine context**:

```java
public record PluginContext(Logger logger, Path dataFolder, BukkitScheduler scheduler) {}
```

* Maak het veld **`private final`**, geen getter die het teruggeeft.

# 14) Projectbrede checks

1. **Zoeken/vervangen:**

   * `getPlugin()` / `plugin` getters die `Plugin` teruggeven → verwijderen of beperken.
   * `return this.field;` waar `field` mutabel is → `unmodifiableXxx` of clone.
   * vermenigvuldigingen van `int*int` die in `long` gaan → cast operand.
2. **Annotaties:**

   * Voeg **spotbugs-annotations** toe en gebruik *gerichte* `@SuppressFBWarnings` met **duidelijke justification** voor echte false positives (bv. Adventure `Component`).
3. **Build-guardrails:**

   * Zet **SpotBugs op “failOnError”** (heb je al) en run lokaal.
   * Voeg **Nullness-annotaties** toe (JetBrains `@NotNull/@Nullable` of Checker Framework) en respecteer ze.
4. **Concurrency:**

   * Vervang counters/timers door **`LongAdder`/`AtomicLong`**.
   * Maak **alle** velden die cross-thread gelezen worden `final`.

# 15) Concreet per bestandsnaam (uit jouw log)

* **EmpireWandAPI.java (LI/SING):** vervang singleton met Holder-idiom.
* **SpellCastEvent.java (EI/EI2):** sla `UUID` i.p.v. `Player`; geen directe getter voor `Player`.
* **WandTemplateImpl.java (EI/EI2/EI):** `displayName` laten staan, maar suppress met motivatie **of** abstraheren naar `String`/`MiniMessage` bij opslag en pas renderen bij gebruik.
* **Afterimages.java (MS):** verberg manager; expose statische façade of interface.
* **OptimizedParticleEngine / AsyncSpellProcessor / MetricsService / FxService / ConfigService (CT/EI2/IS):**

  * verplaats throwing werk naar factory/init, maak velden `final`, gebruik `LongAdder` voor metrics.
* **ProjectileSpell.java (CT/NP):** guard op nullable eventvelden, verplaats init naar builder/factory.
* **Kajarrow\.java (NP):** null-guards op `ProjectileHitEvent` data.
* **SpellManagerImpl.java (EI2/WMI):** geen plugin-getter; gebruik `entrySet`.
* **Mephiaura.java & ShadowCloak.java (ICAST):** vroegtijdig casten.
* **BloodBarrier.java / EmpireAura.java / BindTypeCommand.java (RCN):** verwijder redundante checks.
* **Alle *Listener*(Plugin) constructors (EI2):** velden `private final`, geen getter terug.

---

## Werkvolgorde (aanrader)

1. **EmpireWandAPI singleton** fixen (SING/LI) → unblockt veel.
2. **CT-issues**: verplaats init uit constructors (services/adapters).
3. **EI/EI2** op listeners/services/events + `Afterimages` (grootste bulk).
4. **NP/WMI/ICAST/FL/IS/RV/RCN** als “lint-pass”.
5. **Annotaties & targeted suppressions** (Adventure `Component`).

Wil je dat ik een paar van de ergste klassen (API singleton + één service + één event + één listener) meteen herschrijf naar veilige patronen, zodat je een concrete referentie hebt?
